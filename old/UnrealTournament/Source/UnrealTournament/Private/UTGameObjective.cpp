// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.
#include "UnrealTournament.h"
#include "UTCharacter.h"
#include "UTGameObjective.h"
#include "Net/UnrealNetwork.h"
#include "UTRecastNavMesh.h"
#include "UTDefensePoint.h"

AUTGameObjective::AUTGameObjective(const FObjectInitializer& ObjectInitializer)
: Super(ObjectInitializer)
{
	RootComponent = ObjectInitializer.CreateDefaultSubobject<USceneComponent, USceneComponent>(this, TEXT("DummyRoot"), false);
	CarriedObjectClass = NULL;
	InitialSpawnDelay = 0.0f;
	SetReplicates(true);
	bReplicateMovement = true;
	bAlwaysRelevant = true;
	NetPriority=1.0;
	BestViewYaw = 0.f;
	LastSecondSaveDistance = 2000.f;
	TeamNum = 255;
	bAutogenerateDefensePoints = true;
	ForwardDot = 0.95f;
	HighLowDot = 0.87f;
	IncomingHeightOffset = 300.f;
}

void AUTGameObjective::GetLifetimeReplicatedProps(TArray< FLifetimeProperty > & OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(AUTGameObjective, TeamNum);
	DOREPLIFETIME(AUTGameObjective, CarriedObject);
	DOREPLIFETIME(AUTGameObjective, CarriedObjectState);
	DOREPLIFETIME(AUTGameObjective, CarriedObjectHolder);
}

void AUTGameObjective::InitializeObjective()
{
	if (InitialSpawnDelay > 0.0f)
	{
		FTimerHandle TempHandle;
		GetWorldTimerManager().SetTimer(TempHandle, this, &AUTGameObjective::CreateCarriedObject, InitialSpawnDelay, false);
	}
	else
	{
		CreateCarriedObject();
	}

	if (bAutogenerateDefensePoints)
	{
		GenerateDefensePoints();
	}
}

void AUTGameObjective::GenerateDefensePoints()
{
	AUTRecastNavMesh* NavData = GetUTNavData(GetWorld());
	if (NavData != NULL)
	{
		const FVector MyLoc = GetActorLocation() + FVector(0.0f, 0.0f, 45.0f);
		const UUTPathNode* MyNode = NavData->FindNearestNode(MyLoc, NavData->GetPOIExtent(this));
		TArray<const UUTPathNode*> AllNodes = NavData->GetAllNodes();
		// sort nodes by overall area viability as a defense point
		AllNodes.Sort([](const UUTPathNode& A, const UUTPathNode& B)
		{
			// rate based on number of linked paths and number of polys in this node (implying area size)
			// TODO: calculate actual poly area?
			float RatingA = 0.5f / FMath::Max<int32>(1, A.Paths.Num()) + 0.5f / FMath::Max<int32>(1, A.Polys.Num());
			float RatingB = 0.5f / FMath::Max<int32>(1, B.Paths.Num()) + 0.5f / FMath::Max<int32>(1, A.Polys.Num());
			return RatingA > RatingB;
		});
		struct FPotentialDefensePoint
		{
			FVector Loc;
			float Distance;
		};
		TArray<FPotentialDefensePoint> Choices;
		int32 NumNodesWithChoices = 0;
		for (const UUTPathNode* Node : AllNodes)
		{
			bool bGotChoice = false;
			if (Node != MyNode && !Node->bDestinationOnly)
			{
				for (NavNodeRef TestPoly : Node->Polys)
				{
					const FVector TestLoc = NavData->GetPolyCenter(TestPoly) + FVector(0.0f, 0.0f, NavData->GetPOIExtent(NULL).Z);
					if (!GetWorld()->LineTraceTestByChannel(MyLoc, TestLoc, ECC_Pawn, FCollisionQueryParams(), WorldResponseParams))
					{
						new(Choices) FPotentialDefensePoint{ TestLoc, (TestLoc - MyLoc).Size() };
						if (!bGotChoice)
						{
							NumNodesWithChoices++;
							bGotChoice = true;
						}
					}
				}
				// bail once we have a reasonable variety of options
				if (NumNodesWithChoices > 6)
				{
					break;
				}
			}
		}
		Choices.Sort([](const FPotentialDefensePoint& A, const FPotentialDefensePoint& B) { return A.Distance > B.Distance; });
		Choices.SetNum(FMath::Min<int32>(Choices.Num(), 4));
		for (const FPotentialDefensePoint& Pt : Choices)
		{
			FActorSpawnParameters Params;
			Params.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
			AUTDefensePoint* NewPoint = GetWorld()->SpawnActor<AUTDefensePoint>(Pt.Loc, (MyLoc - Pt.Loc).Rotation(), Params);
			if (NewPoint != NULL)
			{
				NewPoint->Objective = this;
				NewPoint->BasePriority = 1;
				DefensePoints.Add(NewPoint);
			}
		}
	}
}

void AUTGameObjective::CreateCarriedObject()
{
	if (CarriedObjectClass == NULL) return;	// Sanity

	FActorSpawnParameters Params;
	Params.Owner = this;

	CarriedObject = GetWorld()->SpawnActor<AUTCarriedObject>(CarriedObjectClass, GetActorLocation() + FVector(0,0,96), GetActorRotation(), Params);
	if (CarriedObject != NULL)
	{
		CarriedObject->Init(this);
	}
	else
	{
		UE_LOG(UT,Warning,TEXT("%s Could not create an object of type %s"), *GetNameSafe(this), *GetNameSafe(CarriedObjectClass));
	}
}

AUTCarriedObject* AUTGameObjective::GetCarriedObject() const
{
	return CarriedObject;
}

FName AUTGameObjective::GetCarriedObjectState() const
{
	return CarriedObjectState;
}

AUTPlayerState* AUTGameObjective::GetCarriedObjectHolder()
{
	return CarriedObjectHolder;
}

void AUTGameObjective::ObjectWasPickedUp(AUTCharacter* NewHolder, bool bWasHome)
{
	CarriedObjectHolder = NewHolder != NULL ? Cast<AUTPlayerState>(NewHolder->PlayerState) : NULL;
}

void AUTGameObjective::ObjectWasDropped(AUTCharacter* LastHolder)
{
	CarriedObjectHolder = NULL;
}

void AUTGameObjective::ObjectReturnedHome(AUTCharacter* Returner)
{
	CarriedObjectHolder = NULL;
}

void AUTGameObjective::ObjectStateWasChanged(FName NewObjectState)
{
	if (Role==ROLE_Authority)
	{
		CarriedObjectState = NewObjectState;
		OnObjectStateChanged();
	}
}

void AUTGameObjective::OnObjectStateChanged()
{
	// Subclass me
}

bool AUTGameObjective::ActorIsNearMe(AActor *Other) const
{
	return ((Other->GetActorLocation() - GetActorLocation()).Size() < LastSecondSaveDistance);
}
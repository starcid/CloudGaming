// Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
#pragma once

#include "UTAnnouncer.h"
#include "UTATypes.h"
#include "UTLocalMessage.generated.h"

UCLASS(Blueprintable, Abstract, NotPlaceable, meta = (ShowWorldContextPin))
class UNREALTOURNAMENT_API UUTLocalMessage : public ULocalMessage
{
	GENERATED_UCLASS_BODY()

	/** Message area on HUD (index into UTHUD.MessageOffset[]) */
	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = Message)
	FName MessageArea;

	/** Message area on HUD (index into UTHUD.MessageOffset[]) */
	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = Message)
		FName MessageSlot;

	/** If true, this is a Game Status Announcement */
	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = Message)
	uint32 bIsStatusAnnouncement : 1;

	// If true and special, only one can be in the HUD queue at a time.
	UPROPERTY(EditDefaultsOnly, Category = Message)
	uint32 bIsUnique:1;    

	// If true and special, only one can be in the HUD queue with the same switch value
	UPROPERTY(EditDefaultsOnly, Category = Message)
	uint32 bIsPartiallyUnique:1;    

	// If true, put a GetString on the console.
	UPROPERTY(EditDefaultsOnly, Category = Message)
	uint32 bIsConsoleMessage:1;    

	// if true, allow overriding by anything else 
	UPROPERTY(EditDefaultsOnly, Category = Message)
	uint32 bOptionalSpoken : 1;

	// for announcements - will request a bot reaction after playing this announcement. 
	UPROPERTY(EditDefaultsOnly, Category = Message)
	uint32 bWantsBotReaction : 1;

	/** Use special deathmessage handling. */
	UPROPERTY(EditDefaultsOnly, Category = Message)
		uint32 bDrawAsDeathMessage : 1;

	virtual bool ShouldDrawMessage(int32 MessageIndex, class AUTPlayerController* PC, bool bIsAtIntermission, bool bNoLivePawnTarget) const;

	/** Continue to display this message at intermission. */
	UPROPERTY(EditDefaultsOnly, Category = Message)
		uint32 bDrawAtIntermission : 1;

	/** Display only if viewtarget is a live player. */
	UPROPERTY(EditDefaultsOnly, Category = Message)
		uint32 bDrawOnlyIfAlive : 1;

	/** Display/play during intermissions only if viewtarget is a live player. */
	UPROPERTY(EditDefaultsOnly, Category = Message)
		uint32 bPlayDuringIntermission : 1;

	UPROPERTY(EditDefaultsOnly, Category = Message)
		uint32 bPlayDuringInstantReplay : 1;
	
	/** Maximum delay after which this announcement will still play. */
	UPROPERTY(EditDefaultsOnly, Category = Message)
		float MaxAnnouncementDelay;

	virtual float GetMaxAnnouncementDelay(const FAnnouncementInfo AnnouncementInfo) { return MaxAnnouncementDelay; };

	/** Return true if announcement is still valid and should still play. */
	virtual bool ShouldStillPlay(class AUTGameState* GS, const FAnnouncementInfo AnnouncementInfo) const;

	/** If true combine emphasis text with already displaying message of same class. */
	UPROPERTY(EditDefaultsOnly, Category = Message)
		uint32 bCombineEmphasisText : 1;	

	virtual FText CombineEmphasisText(int32 CombinedMessageIndex, FText CombinedEmphasisText, FText OriginalEmphasisText) const
	{
		return OriginalEmphasisText;
	};

	virtual FText CombinePrefixText(int32 CombinedMessageIndex,FText OriginalPrefixText) const
	{
		return OriginalPrefixText;
	};

	virtual FText CombineText(int32 CombinedMessageIndex, FText CombinedEmphasisText, FText OriginalCombinedText) const
	{
		return OriginalCombinedText;
	};

	// # of seconds to stay in HUD message queue.
	UPROPERTY(EditDefaultsOnly, Category = Message)
	float Lifetime;    

	// how long to delay playing this announcement
	UPROPERTY(EditDefaultsOnly, Category = Message)
	float AnnouncementDelay;

	UPROPERTY(EditDefaultsOnly, Category = Message)
		float ScaleInSize;

	UPROPERTY(EditDefaultsOnly, Category = Message)
		float ScaleInTime;

	/** 0=smallest font, 3=largest font. */
	UPROPERTY(EditDefaultsOnly, Category = Message)
		int32 FontSizeIndex;

	/** Return what destination type to show for chat message */
	virtual int32 GetDestinationIndex(int32 MessageIndex) const
	{
		return 0;
	}

	virtual bool EnableAnnouncerLogging() const
	{
		return false;
	}

	virtual bool IsOptionalSpoken(int32 MessageIndex) const;

	virtual int32 GetFontSizeIndex(int32 MessageIndex, bool bTargetsLocalPlayer) const;

	virtual float GetAnnouncementDelay(int32 Switch);

	virtual bool ShouldPlayAnnouncement(const FClientReceiveData& ClientData) const;

	virtual void ClientReceive(const FClientReceiveData& ClientData) const override;

	virtual void GetEmphasisText(FText& PrefixText, FText& EmphasisText, FText& PostfixText, FLinearColor& EmphasisColor, int32 Switch, class APlayerState* RelatedPlayerState_1, class APlayerState* RelatedPlayerState_2, class UObject* OptionalObject) const;

	/** Returns full string built from the parts generated by GetEmphasisText(). */
	virtual FText BuildEmphasisText(int32 Switch, class APlayerState* RelatedPlayerState_1, class APlayerState* RelatedPlayerState_2, class UObject* OptionalObject) const;

	UFUNCTION(BlueprintImplementableEvent, Category = Message)
	void OnClientReceive(APlayerController* LocalPC, int32 Switch, APlayerState* RelatedPlayerState_1, APlayerState* RelatedPlayerState_2, UObject* OptionalObject) const;

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = Message)
	FText ResolveMessage(int32 Switch = 0, bool bTargetsPlayerState1 = false, class APlayerState* RelatedPlayerState_1 = NULL, class APlayerState* RelatedPlayerState_2 = NULL, class UObject* OptionalObject = NULL) const;

	/** Returns string to display on console for this message. */
	virtual FString GetConsoleString(const FClientReceiveData& ClientData, FText LocalMessageText) const;

	/** return the spacing to wait before playing this announcement if directly following another announcement. */
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, BlueprintPure, Category = Message)
	float GetAnnouncementSpacing(int32 Switch, const UObject* OptionalObject) const;

	/** return the name of announcement to play for this message (if any); UTAnnouncer will map to an actual sound */
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, BlueprintPure, Category = Message)
	FName GetAnnouncementName(int32 Switch, const UObject* OptionalObject, const class APlayerState* RelatedPlayerState_1, const class APlayerState* RelatedPlayerState_2) const;

	/** return the sound to play for the announcement, if GetAnnouncementName() returned NAME_Custom. */
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, BlueprintPure, Category = Message)
	USoundBase* GetAnnouncementSound(int32 Switch, const UObject* OptionalObject) const;

	/** Return true if local player is viewing first or second playerstate. */
	virtual bool IsLocalForAnnouncement(const FClientReceiveData& ClientData, bool bCheckFirstPS, bool bCheckSecondPS) const;

	/** Return color of displayed message. */
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, BlueprintPure, Category = Message)
	FLinearColor GetMessageColor(int32 MessageIndex) const;

	/** How long to scale to 1 from initial message scale. */
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, BlueprintPure, Category = Message)
	float GetScaleInTime(int32 MessageIndex) const;

	/** Initial Message scale */
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, BlueprintPure, Category = Message)
	float GetScaleInSize(int32 MessageIndex) const;

	/** if true, if sent to HUD multiple times, count up instances (only if bIsUnique) */
	/** return whether this announcement should be cancelled by the passed in announcement */
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, BlueprintPure, Category = Message)
	bool ShouldCountInstances(int32 MessageIndex, UObject* OptionalObject) const;

	/** return whether this announcement should interrupt/cancel the passed in other announcement */
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, BlueprintPure, Category = Message)
	bool InterruptAnnouncement(int32 Switch, const UObject* OptionalObject, TSubclassOf<UUTLocalMessage> OtherMessageClass, int32 OtherSwitch, const UObject* OtherOptionalObject) const;

	virtual bool InterruptAnnouncement(const FAnnouncementInfo AnnouncementInfo, const FAnnouncementInfo OtherAnnouncementInfo) const;

	/** return whether this announcement should be cancelled by the passed in other announcement */
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, BlueprintPure, Category = Message)
	bool CancelByAnnouncement(int32 Switch, const UObject* OptionalObject, TSubclassOf<UUTLocalMessage> OtherMessageClass, int32 OtherSwitch, const UObject* OtherOptionalObject) const;

	/** called when the UTAnnouncer plays the announcement sound - can be used to e.g. display HUD text at the same time */
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = Message)
	void OnAnnouncementPlayed(int32 Switch, const UObject* OptionalObject) const;

	/** called to precache announcer sounds at startup, since they're dynamically loaded to enable custom announcer packs */
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = Message)
	void PrecacheAnnouncements(class UUTAnnouncer* Announcer) const;

	virtual void GetArgs(FFormatNamedArguments& Args, int32 Switch = 0, bool bTargetsPlayerState1 = false, class APlayerState* RelatedPlayerState_1 = NULL, class APlayerState* RelatedPlayerState_2 = NULL, class UObject* OptionalObject = NULL) const;
	
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = Message)
	virtual FText GetText(int32 Switch = 0, bool bTargetsPlayerState1 = false, class APlayerState* RelatedPlayerState_1 = NULL, class APlayerState* RelatedPlayerState_2 = NULL, class UObject* OptionalObject = NULL) const;

	/**	Give Blueprints a way to override the text generated by this local message. */
	UFUNCTION(BlueprintNativeEvent, Category = Message)
	FText Blueprint_GetText(int32 Switch, bool bTargetsPlayerState1, class APlayerState* RelatedPlayerState_1, class APlayerState* RelatedPlayerState_2, class UObject* OptionalObject) const;
	
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = Message)
	virtual float GetLifeTime(int32 Switch) const;

	/** Range of 0 to 1, affects where announcement is inserted into pending announcements queue. */
	virtual float GetAnnouncementPriority(const FAnnouncementInfo AnnouncementInfo) const;

	/**	Give Blueprints a way to override the lifetime for this message */
	UFUNCTION(BlueprintNativeEvent, Category = Message)
	float Blueprint_GetLifeTime(int32 Switch) const;

	virtual bool IsConsoleMessage(int32 Switch) const;
	bool PartiallyDuplicates(int32 Switch1, int32 Switch2, class UObject* OptionalObject1, class UObject* OptionalObject2 ) const;

	/** return the UMG object to display instead of the message or Empty() if no UMG widget is assocated with this switch */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = Message)
	virtual FString GetAnnouncementUMGClassname(int32 Switch, const UObject* OptionalObject) const;

};



